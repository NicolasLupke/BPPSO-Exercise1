#!/usr/bin/env python3
# Hard-coded bundler: inputs ./micropm4py/, outputs ./bundled_package.py

from __future__ import annotations

import base64
import hashlib
import io
import sys
import time
import zipfile
from pathlib import Path
from string import Template

import os

os.chdir("..")

PACKAGE_DIR = Path("pm4py")        # folder containing __init__.py
OUTPUT_FILE = Path("bundled_package.py")
DEFAULT_MODE = "auto"                   # "auto" | "module" | "none"
ENTRYPOINT = None                       # e.g. "micropm4py.cli:main" or None


BUNDLE_TEMPLATE = Template(r"""# -*- coding: utf-8 -*-
# Generated by a hard-coded bundler on $timestamp
# Package: $pkg_name
# WARNING: This file is auto-generated. Edits may be overwritten.

import base64
import importlib
import io
import os
import runpy
import sys
import tempfile
import time

_EMBEDDED_ZIP_B64 = $zip_b64_literal
_PKG_NAME = $pkg_name_literal
_DEFAULT_MODE = $default_mode_literal  # "auto" | "module" | "none"
_ENTRYPOINT = $entrypoint_literal      # e.g. "pkg.module:main" or None

def _ensure_zip_on_sys_path():
    data = base64.b64decode(_EMBEDDED_ZIP_B64)
    digest = "sha256-" + $digest_literal
    tempdir = tempfile.gettempdir()
    zip_path = os.path.join(tempdir, f"{_PKG_NAME}-{digest}.pyz")

    if not os.path.exists(zip_path):
        tmppath = zip_path + ".tmp-" + str(int(time.time() * 1000))
        with open(tmppath, "wb") as f:
            f.write(data)
        try:
            os.replace(tmppath, zip_path)
        except Exception:
            try:
                os.rename(tmppath, zip_path)
            finally:
                try:
                    if os.path.exists(tmppath):
                        os.remove(tmppath)
                except Exception:
                    pass

    if zip_path not in sys.path:
        sys.path.insert(0, zip_path)

def _maybe_run_entrypoint():
    if _ENTRYPOINT:
        mod, _, func = _ENTRYPOINT.partition(":")
        if not mod or not func:
            raise SystemExit(f"Invalid entrypoint {_ENTRYPOINT!r}; expected 'module:callable'")
        module = importlib.import_module(mod)
        target = getattr(module, func, None)
        if target is None:
            raise SystemExit(f"Entrypoint function {func!r} not found in module {mod!r}")
        target()
        return True

    if _DEFAULT_MODE in ("module", "auto"):
        try:
            importlib.import_module(_PKG_NAME + ".__main__")
            runpy.run_module(_PKG_NAME, run_name="__main__")
            return True
        except ModuleNotFoundError:
            if _DEFAULT_MODE == "module":
                raise SystemExit(f"Package {_PKG_NAME!r} has no __main__.py to run.")
    return False

_ensure_zip_on_sys_path()

def bundled_contains(module_name: str) -> bool:
    try:
        importlib.import_module(module_name)
        return True
    except Exception:
        return False

if __name__ == "__main__":
    ran = _maybe_run_entrypoint()
    if not ran and sys.stdout.isatty():
        print(f"[bundle] Embedded package {_PKG_NAME!r} is on sys.path.")
        print(f" - Import it:  >>> import {_PKG_NAME}")
        print(" - Or set an entrypoint inside this file and re-run.")
""")

def _require_pkg_dir(pkg_dir: Path) -> str:
    if not pkg_dir.exists() or not pkg_dir.is_dir():
        sys.exit(f"ERROR: package directory not found: {pkg_dir}")
    init_py = pkg_dir / "__init__.py"
    if not init_py.exists():
        sys.exit(f"ERROR: {pkg_dir} is not a package (missing __init__.py).")
    return pkg_dir.name

def _zip_package_with_parent(pkg_dir: Path) -> bytes:
    parent = pkg_dir.parent
    buf = io.BytesIO()
    with zipfile.ZipFile(buf, "w", compression=zipfile.ZIP_DEFLATED, compresslevel=9) as zf:
        for path in pkg_dir.rglob("*"):
            if path.is_dir():
                continue
            arcname = path.relative_to(parent)
            zf.write(path, arcname=str(arcname))
    return buf.getvalue()

def _b64_literal(b: bytes, wrap: int = 76) -> str:
    s = base64.b64encode(b).decode("ascii")
    if wrap:
        s = "\n".join(s[i:i+wrap] for i in range(0, len(s), wrap))
    return '("""\n' + s + '\n""")'

def _py_str(s: str) -> str:
    return repr(s)

def _sha256(b: bytes) -> str:
    import hashlib
    return hashlib.sha256(b).hexdigest()

def main():
    pkg_dir = PACKAGE_DIR.resolve()
    pkg_name = _require_pkg_dir(pkg_dir)

    zip_bytes = _zip_package_with_parent(pkg_dir)

    # verify archive has expected top-level path
    with zipfile.ZipFile(io.BytesIO(zip_bytes), "r") as zf:
        expect = f"{pkg_name}/__init__.py"
        if expect not in zf.namelist():
            sys.exit(f"INTERNAL ERROR: expected {expect} in archive")

    out_text = BUNDLE_TEMPLATE.substitute(
        timestamp=time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
        pkg_name=pkg_name,
        pkg_name_literal=_py_str(pkg_name),
        default_mode_literal=_py_str(DEFAULT_MODE),
        entrypoint_literal=_py_str(ENTRYPOINT) if ENTRYPOINT else "None",
        digest_literal=_py_str(_sha256(zip_bytes)),
        zip_b64_literal=_b64_literal(zip_bytes),
    )

    out_path = OUTPUT_FILE.resolve()
    out_path.write_text(out_text, encoding="utf-8")

    # make executable on POSIX; harmless on Windows
    try:
        mode = out_path.stat().st_mode
        out_path.chmod(mode | 0o111)
    except Exception:
        pass

    print(f"Bundled {pkg_name!r} -> {out_path}")

if __name__ == "__main__":
    main()
